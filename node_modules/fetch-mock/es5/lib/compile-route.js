'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./debug'),
    getDebug = _require.getDebug;

var generateMatcher = require('./generate-matcher');

var matcherProperties = ['query', 'method', 'headers', 'params', 'body', 'functionMatcher', 'url'];

var isUrlMatcher = function isUrlMatcher(matcher) {
	return matcher instanceof RegExp || typeof matcher === 'string' || (typeof matcher === 'undefined' ? 'undefined' : (0, _typeof3.default)(matcher)) === 'object' && 'href' in matcher;
};

var isFunctionMatcher = function isFunctionMatcher(matcher) {
	return typeof matcher === 'function';
};

var argsToRoute = function argsToRoute(args) {
	var _args = (0, _slicedToArray3.default)(args, 3),
	    matcher = _args[0],
	    response = _args[1],
	    _args$ = _args[2],
	    options = _args$ === undefined ? {} : _args$;

	var routeConfig = {};

	if (isUrlMatcher(matcher) || isFunctionMatcher(matcher)) {
		routeConfig.matcher = matcher;
	} else {
		(0, _assign2.default)(routeConfig, matcher);
	}

	if (response) {
		routeConfig.response = response;
	}

	(0, _assign2.default)(routeConfig, options);
	return routeConfig;
};

var sanitizeRoute = function sanitizeRoute(route) {
	var debug = getDebug('sanitizeRoute()');
	debug('Sanitizing route properties');
	route = (0, _assign2.default)({}, route);

	if (route.method) {
		debug('Converting method ' + route.method + ' to lower case');
		route.method = route.method.toLowerCase();
	}
	if (isUrlMatcher(route.matcher)) {
		debug('Mock uses a url matcher', route.matcher);
		route.url = route.matcher;
		delete route.matcher;
	}

	route.functionMatcher = route.matcher || route.functionMatcher;

	debug('Setting route.identifier...');
	debug('  route.name is ' + route.name);
	debug('  route.url is ' + route.url);
	debug('  route.functionMatcher is ' + route.functionMatcher);
	route.identifier = route.name || route.url || route.functionMatcher;
	debug('  -> route.identifier set to ' + route.identifier);
	return route;
};

var validateRoute = function validateRoute(route) {
	if (!('response' in route)) {
		throw new Error('fetch-mock: Each route must define a response');
	}

	if (!matcherProperties.some(function (matcherType) {
		return matcherType in route;
	})) {
		throw new Error("fetch-mock: Each route must specify some criteria for matching calls to fetch. To match all calls use '*'");
	}
};

var limit = function limit(route) {
	var debug = getDebug('limit()');
	debug('Limiting number of requests to handle by route');
	if (!route.repeat) {
		debug('  No `repeat` value set on route. Will match any number of requests');
		return;
	}

	debug('  Route set to repeat ' + route.repeat + ' times');
	var matcher = route.matcher;
	var timesLeft = route.repeat;
	route.matcher = function (url, options) {
		var match = timesLeft && matcher(url, options);
		if (match) {
			timesLeft--;
			return true;
		}
	};
	route.reset = function () {
		return timesLeft = route.repeat;
	};
};

var delayResponse = function delayResponse(route) {
	var debug = getDebug('delayResponse()');
	debug('Applying response delay settings');
	var delay = route.delay;

	if (delay) {
		debug('  Wrapping response in delay of ' + delay + ' miliseconds');
		var response = route.response;
		route.response = function () {
			debug('Delaying response by ' + delay + ' miliseconds');
			return new _promise2.default(function (res) {
				return setTimeout(function () {
					return res(response);
				}, delay);
			});
		};
	} else {
		debug('  No delay set on route. Will respond \'immediately\' (but asynchronously)');
	}
};

var compileRoute = function compileRoute(args) {
	var debug = getDebug('compileRoute()');
	debug('Compiling route');
	var route = sanitizeRoute(argsToRoute(args));
	validateRoute(route);
	route.matcher = generateMatcher(route);
	limit(route);
	delayResponse(route);
	return route;
};

module.exports = {
	compileRoute: compileRoute,
	sanitizeRoute: sanitizeRoute
};